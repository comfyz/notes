# 4. mysql剖析
### a.**mysql逻辑架构**
![mysql](../images/mysql.png)

### b.**sql执行过程**

- 程序通过Connectors（链接器）连接到mysql `认证` `授权` `连接`
- mysql将连接放入Connection Pool（连接池），并交由Management Services & Utilities（控制器）管理
- 管理器将请求交给SQL Interface（SQL接口），SQL Interface对sql进行hash并与Cache & Buffer（缓存）中结果对比，匹配直接返回结果，未匹配则继续
- SQL Interface 交给 Parser（解释器），验证sql正确性，转化为规范数据结构
- Optimizer（优化器）分析sql产生最优执行方案
- Storage Engine（存储引擎）执行sql，从File System（文件系统）中检索到数据并返回，同时对sql进行hash缓存一份结果到Cache & Buffer中。
- 如果是修改操作则添加一份Files & Logs信息

### **存储引擎及索引优化**
```
// TODO : 明日完善
```
### c. **InnoDB执行过程及事务原理** 

- 事务ACID `原子性` `一致性` `隔离性` `持久性`
- 事务日志（UNDO/REDO机制）实现原子性
- mvcc机制（结合undolog）和行锁表锁实现隔离 `多版本数据快照` `undolog指针` `事务计数器(undolog的行)` `行号(新增)` `删除标识(删除)`
- select `查询版本号小于等于当前事务版本的数据`
    ```
    1. 按索引查询缓存，没有则2，有则3
    2. 加载磁盘数据页至缓存
    3. 返回
    ```
- DML（insert，update，delete）
    ```
    1. insert操作直接3，查询缓存，没有则2，有则3
    2. 加载磁盘数据页至缓存
    3. 对数据行加锁，写undo页，mvcc生成快照并修改，同步到redolog buffer，设计索引更新使用insertbuffer
    4. 事务提交后记录到binlog，redolog buffer刷到redolog，insertbuffer刷新到索引
    5. 释放锁，修改的数据放到flush list（缓存页）等待page cleaner thread刷新到磁盘。
    6. undo page如果没有被其他事务引用，则放入history list等待被purge线程回收
    ```
- 内部线程
    - master thread
        ```
        负责刷新缓存数据到磁盘并协调调度其它后台进程。
        ```
    - IO thread
        ```
        分为 insert buffer、log、read、write进程。分别用来处理insert buffer、重做日志、读写请求的IO回调。
        ```
    - purge thread `用来回收undo 页`
    - page cleaner thread `用来刷新脏页`。
- 脏页的刷新使用checkpoint机制 `定时刷新` `超过大小刷新`