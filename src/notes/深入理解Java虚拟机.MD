# Java虚拟机
```
Java是编译型高级语言，基于jvm实现跨平台，提供自动内存管理机制
``` 
1. 为什么GC？
2. 如何GC
    - 垃圾定位
    - 垃圾收集算法
        - 标记清除
        - 复制
        - 标记整理
        - 分代
            - 年轻代 `eden` `surviver12` `GC age`
            - 老年代
            - 块
    - 回收策略
        - 串行
        - 并行
        - 并发
3. jvm内存模型
    - 程序计数器
    - java虚拟机栈
    - 本地方法栈
    - 堆
    - 元空间
    - 直接内存
4. 垃圾收集器
    - MinorGC
        - Serial
        - ParNew
        - ParallelSeavenge
        - G1
    - MajorGC
        - CMS
        - Serial Old (MSC)
        - Parallel Old
        - G1
        
4. 对象的创建到销毁
    - 类加载
    - 创建实例
    - 内存分配 `TLAB` `Pointer Dump`
    - GC过程，内存变化
    - GC后销毁
    
5. JVM调优
    
6. OOM排查过程



















乱七八糟的描述
了解GC时候首先我们要知道
1. 为什么GC，jvm提供自动GC的工作是因为想把棘手的内存回收问题从程序猿手上释放出来，
避免类似于c++需要去考虑复杂的内存分配及回收问题。所以现在jvm接管内存回收之后需要开始考虑问题
2. 哪些内存是需要回收的，被当做垃圾的，这里就引出了
3. 垃圾标记算法，垃圾标记算法的话最简单的方式就是我们分配内存的时候给他加一个引用计数，
第一次为1，以后其他引用指向他则把计数+1，垃圾回收的时候清理引用计数为0的即可。
4. 这样做有没有什么缺陷？
考虑这样一个场景，A实例包含一个对B实例的引用，B实例包含一个对A实例的引用，或者类似一个环状的引用，
在环状相互引用的状态下，每个计数器永远不会小于1，但是这个环状结构对其他任何实例来说是不可达的，
即他们就是需要回收的垃圾，但是当回收时判断由于引用计数大于0，造成内存泄露。这种垃圾算法一直都是
一个理论的标记算法，没有任何一家jvm使用。上面提到过一个不可达，我们可以理解，如果某个对象对其他
jvm中存在的实例或者引用都是不可达，那么就是需要回收的垃圾。所以需要从可达性分析，问题来了，
4. 从哪里开始检查标记？或者哪些可以被当做GC Roots。